{
  "hash": "482ca12b8cd022fbf67875e647f35117",
  "result": {
    "markdown": "---\ntitle: \"Function\"\n---\n\n\n\n\n## Fundamentals\n\n### Function Components\n\nR functions are objects in their own right or “first-class functions”.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf02 <- function(x, y) {\n  # A comment\n  x + y\n}\n\ntypeof(f02)\n#> [1] \"closure\"\nclass(f02)\n#> [1] \"function\"\nsloop::ftype(f02)\n#> [1] \"function\"\nsloop::otype(f02)\n#> [1] \"base\"\n```\n:::\n\n\n3 Function components\n\n\n::: {.cell}\n\n```{.r .cell-code}\nformals(f02)\n#> $x\n#> \n#> \n#> $y\nbody(f02)\n#> {\n#>     x + y\n#> }\nenvironment(f02)\n#> <environment: R_GlobalEnv>\n```\n:::\n\n\n\n`srcref` attribute is used for printing the source code.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattributes(f02)\n#> $srcref\n#> function(x, y) {\n#>   # A comment\n#>   x + y\n#> }\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nprint.function(f02)\n#> function(x, y) {\n#>   # A comment\n#>   x + y\n#> }\n```\n:::\n\n\n### First-class Function\n\n**anonymous function** (no name binding is necessary)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(mtcars, function(x) length(unique(x)))\nFilter(function(x) !is.numeric(x), mtcars)\nintegrate(function(x) sin(x) ^ 2, 0, pi)\n```\n:::\n\n\n**List of functions**\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfuns <- list(\n  half = function(x) x / 2,\n  double = function(x) x * 2\n)\n\nfuns$double(10)\n#> [1] 20\n```\n:::\n\n\n### `do.call()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nargs <- list(1:10, na.rm = TRUE)\ndo.call(mean, args)\n#> [1] 5.5\n```\n:::\n\n\n### Exercise\n\n1. `match.fun()` finds the function\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatch.fun(\"mean\")\n#> function (x, ...) \n#> UseMethod(\"mean\")\n#> <bytecode: 0x7f7c4028a358>\n#> <environment: namespace:base>\n```\n:::\n\n\n2. Calling anonymous function\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(function(x) x + 1)\n#> [1] \"function\"\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n(function(x) x + 1)(2)\n#> [1] 3\n```\n:::\n\n\n3. List all function in base\n\n\n::: {.cell}\n\n```{.r .cell-code}\nobjs <- mget(ls(\"package:base\", all = TRUE), inherits = TRUE)\nfuns <- Filter(is.function, objs)\n```\n:::\n\n\nFind functions that has most arguments\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\nlibrary(dplyr)\nlibrary(tibble)\n```\n:::\n\n\nHelper to counts number of arguments\n\n\n::: {.cell}\n\n```{.r .cell-code}\nget_num_args <- function(f){\n  \n  args <- formals(f)\n  if(is.null(args)) return(NA_integer_) # for primitive function\n  length(args)\n  \n}\n\nget_num_args(f02)\n#> [1] 2\nget_num_args(sum)\n#> [1] NA\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbasefuns_tbl <- map_dbl(funs, get_num_args) %>% \n  enframe(\"base_fun\", \"num_args\")\n```\n:::\n\n\nBase functions that has most arguments\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbasefuns_tbl %>% \n  arrange(desc(num_args)) %>% \n  head()\n#> # A tibble: 6 × 2\n#>   base_fun         num_args\n#>   <chr>               <dbl>\n#> 1 scan                   22\n#> 2 format.default         16\n#> 3 source                 16\n#> 4 formatC                15\n#> 5 library                13\n#> 6 merge.data.frame       13\n```\n:::\n",
    "supporting": [
      "function_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}