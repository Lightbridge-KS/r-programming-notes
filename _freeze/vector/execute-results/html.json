{
  "hash": "8efc3b578b22a884ad5576733f034059",
  "result": {
    "markdown": "# Vector {#vectors-chap}\n\n\n\n## Overview\n\n::: {.cell}\n::: {.cell-output-display}\n![Type of vectors](diagrams/vector.drawio.svg){#fig-vector width=80%}\n:::\n:::\n\n## Atomic Vectors\n\n-   logical\n-   numeric: integer, double\n-   character\n\n### Scalar\n\n::: {.cell}\n\n```{.r .cell-code}\nlgl_var <- c(TRUE, FALSE)\nint_var <- c(1L, 6L, 10L)\ndbl_var <- c(1, 2.5, 4.5)\nchr_var <- c(\"these are\", \"some strings\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(lgl_var)\n#> [1] \"logical\"\ntypeof(int_var)\n#> [1] \"integer\"\ntypeof(dbl_var)\n#> [1] \"double\"\ntypeof(chr_var)\n#> [1] \"character\"\n```\n:::\n\n### Longer Vector\n\n`c()` will flattens\n\n::: {.cell}\n\n```{.r .cell-code}\nc(c(1, 2), c(3, 4))\n#> [1] 1 2 3 4\n```\n:::\n\n### Missing Value\n\n`NA` will propagate except\n\n::: {.cell}\n\n```{.r .cell-code}\nNA ^ 0\n#> [1] 1\n\nNA | TRUE\n#> [1] TRUE\n\nNA & FALSE\n#> [1] FALSE\n```\n:::\n\n**Checking `NA`**\n\nDon't use this to check `NA`\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(NA, 5)\nx == NA\n#> [1] NA NA\n```\n:::\n\nUse this to check `NA`\n\n::: {.cell}\n\n```{.r .cell-code}\nis.na(x)\n#> [1]  TRUE FALSE\n```\n:::\n\nTypes of `NA`\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(NA_integer_)\n#> [1] \"integer\"\ntypeof(NA_real_)\n#> [1] \"double\"\ntypeof(NA_character_)\n#> [1] \"character\"\n```\n:::\n\nThis distinction is usually unimportant because NA will be automatically coerced to the correct type when needed.\n\n### Testing\n\nAvoid [`is.vector()`](https://rdrr.io/r/base/vector.html), [`is.atomic()`](https://rdrr.io/r/base/is.recursive.html), and [`is.numeric()`](https://rdrr.io/r/base/numeric.html): they don't test if you have a vector, atomic vector, or numeric vector; you'll need to carefully read the documentation to figure out what they actually do.\n\nUse this.\n\n::: {.cell}\n\n```{.r .cell-code}\nis.logical(T)\n#> [1] TRUE\nis.integer(1L)\n#> [1] TRUE\nis.double(2)\n#> [1] TRUE\nis.character(\"Hi\")\n#> [1] TRUE\n```\n:::\n\n### Coercion\n\nCombining different types of atomic vector they will be coerced in this order\n\n::: {.callout-note icon=\"false\"}\n#### Coercion\n\nlogical → integer → double → character\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(c(F, 1))\n#>  num [1:2] 0 1\nstr(c(1, \"a\"))\n#>  chr [1:2] \"1\" \"a\"\n```\n:::\n\nCoerce Logical to Numeric can be useful\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(FALSE, FALSE, TRUE)\nas.numeric(x)\n#> [1] 0 0 1\n\n# Total number of TRUEs\nsum(x)\n#> [1] 1\n\n# Proportion that are TRUE\nmean(x)\n#> [1] 0.3333333\n```\n:::\n\nDeliberate coercion with warning message\n\n::: {.cell}\n\n```{.r .cell-code}\nas.integer(c(\"1\", \"1.5\", \"a\"))\n#> Warning: NAs introduced by coercion\n#> [1]  1  1 NA\n```\n:::\n\n## Attributes\n\n### Set and Get Attributes\n\nSet & Get specific attributes: `attr()`\n\nSet all attributes: `structure()`\n\nGet all attributes: `attributes()`\n\n::: {.cell}\n\n```{.r .cell-code}\na <- 1:3\nattr(a, \"x\") <- \"abcdef\"\nattr(a, \"x\")\n#> [1] \"abcdef\"\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nattr(a, \"y\") <- 4:6\nstr(attributes(a))\n#> List of 2\n#>  $ x: chr \"abcdef\"\n#>  $ y: int [1:3] 4 5 6\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Or equivalently\na <- structure(\n  1:3, \n  x = \"abcdef\",\n  y = 4:6\n)\nstr(attributes(a))\n#> List of 2\n#>  $ x: chr \"abcdef\"\n#>  $ y: int [1:3] 4 5 6\n```\n:::\n\nAttributes should generally be thought of as **ephemeral**.\n\n::: {.cell}\n\n```{.r .cell-code}\nattributes(a[1])\n#> NULL\nattributes(sum(a))\n#> NULL\n```\n:::\n\nThere are only two attributes that are routinely preserved:\n\n-   **names**\n\n-   **dim**\n\nCreate S3 class to preserve other attributes.\n\n### Names\n\nYou can name a vector in three ways:\n\n::: {.cell}\n\n```{.r .cell-code}\n# When creating it: \nx <- c(a = 1, b = 2, c = 3)\n\n# By assigning a character vector to names()\nx <- 1:3\nnames(x) <- c(\"a\", \"b\", \"c\")\n\n# Inline, with setNames():\nx <- setNames(1:3, c(\"a\", \"b\", \"c\"))\n```\n:::\n\nRemove names from a vector by using `x <- unname(x)` or `names(x) <- NULL`.\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- c(a = 1, 2)\nnames(y)\n#> [1] \"a\" \"\"\n\ny <- unname(y)\nnames(y)\n#> NULL\n```\n:::\n\n**missing names** may be either \"\" or `NA_character_`. If all names are missing, names() will return NULL.\n\n### Dimensions\n\nAdding a `dim` attribute to a vector allows it to behave like a 2-dimensional matrix or a multi-dimensional array.\n\n**`matrix()`**\n\n::: {.cell}\n\n```{.r .cell-code}\n# Two scalar arguments specify row and column sizes\nx <- matrix(1:6, nrow = 2, ncol = 3)\nx\n#>      [,1] [,2] [,3]\n#> [1,]    1    3    5\n#> [2,]    2    4    6\n```\n:::\n\n**`array()`**\n\n::: {.cell}\n\n```{.r .cell-code}\n# One vector argument to describe all dimensions\ny <- array(1:12, c(2, 3, 2))\ny\n#> , , 1\n#> \n#>      [,1] [,2] [,3]\n#> [1,]    1    3    5\n#> [2,]    2    4    6\n#> \n#> , , 2\n#> \n#>      [,1] [,2] [,3]\n#> [1,]    7    9   11\n#> [2,]    8   10   12\n```\n:::\n\n**`dim()`**\n\n::: {.cell}\n\n```{.r .cell-code}\n# You can also modify an object in place by setting dim()\nz <- 1:6\ndim(z) <- c(3, 2)\nz\n#>      [,1] [,2]\n#> [1,]    1    4\n#> [2,]    2    5\n#> [3,]    3    6\n```\n:::\n\nMany of the functions for working with vectors have generalisations for matrices and arrays:\n\n| Vector            | Matrix                     | Array            |\n|-------------------|----------------------------|------------------|\n| `names()`         | `rownames()`, `colnames()` | `dimnames()`     |\n| `length()`        | `nrow()`, `ncol()`         | `dim()`          |\n| `c()`             | `rbind()`, `cbind()`       | `abind::abind()` |\n| ---               | `t()`                      | `aperm()`        |\n| `is.null(dim(x))` | `is.matrix()`              | `is.array()`     |\n\n1-dimension, but not the same\n\n::: {.cell}\n\n```{.r .cell-code}\nstr(1:3)                   # 1d vector\n#>  int [1:3] 1 2 3\nstr(matrix(1:3, ncol = 1)) # column vector\n#>  int [1:3, 1] 1 2 3\nstr(matrix(1:3, nrow = 1)) # row vector\n#>  int [1, 1:3] 1 2 3\nstr(array(1:3, 3))         # \"array\" vector\n#>  int [1:3(1d)] 1 2 3\n```\n:::\n\n## S3 Atomic Vectors\n\n### Factors\n\nFactors are built on top of an **integer vector**, can contain only predefined values.\n\nHas two attributes\n\n-   **class**: \"factor\"\n-   **levels**: defines the set of allowed values.\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- factor(c(\"a\", \"b\", \"b\", \"a\"))\nx\n#> [1] a b b a\n#> Levels: a b\ntypeof(x)\n#> [1] \"integer\"\nattributes(x)\n#> $levels\n#> [1] \"a\" \"b\"\n#> \n#> $class\n#> [1] \"factor\"\n```\n:::\n\nWhen you tabulate a factor you'll get counts of all categories, even unobserved ones:\n\n::: {.cell}\n\n```{.r .cell-code}\n# Character\nsex_char <- c(\"m\", \"m\", \"m\")\ntable(sex_char)\n#> sex_char\n#> m \n#> 3\n# Factor\nsex_factor <- factor(sex_char, levels = c(\"m\", \"f\"))\ntable(sex_factor)\n#> sex_factor\n#> m f \n#> 3 0\n```\n:::\n\n### Ordered factors\n\nThey behave like regular factors, but the order of the levels is meaningful (leveraged by some modelling and visualisation functions)\n\n::: {.cell}\n\n```{.r .cell-code}\ngrade <- ordered(c(\"b\", \"b\", \"a\", \"c\"), levels = c(\"c\", \"b\", \"a\"))\ngrade\n#> [1] b b a c\n#> Levels: c < b < a\n```\n:::\n\n::: callout-note\n#### Factor as String\n\nBest to explicitly convert factors to character vectors if you need string-like behaviour.\n:::\n\n### Date\n\nDate vectors are built on top of double vectors. They have class \"Date\" and no other attributes:\n\n::: {.cell}\n\n```{.r .cell-code}\ntoday <- Sys.Date()\n\ntypeof(today)\n#> [1] \"double\"\nattributes(today)\n#> $class\n#> [1] \"Date\"\n```\n:::\n\nThe value of the double represents the number of **days** since 1970-01-01.\n\n::: {.cell}\n\n```{.r .cell-code}\ndate <- as.Date(\"1970-02-01\")\nunclass(date)\n#> [1] 31\n```\n:::\n\n### Date-times\n\nvalue represents the number of **seconds** since 1970-01-01.\n\n::: {.cell}\n\n```{.r .cell-code}\nnow_ct <- as.POSIXct(\"2018-08-01 22:00\", tz = \"UTC\")\nnow_ct\n#> [1] \"2018-08-01 22:00:00 UTC\"\n\ntypeof(now_ct)\n#> [1] \"double\"\nattributes(now_ct)\n#> $class\n#> [1] \"POSIXct\" \"POSIXt\" \n#> \n#> $tzone\n#> [1] \"UTC\"\nunclass(now_ct)\n#> [1] 1533160800\n#> attr(,\"tzone\")\n#> [1] \"UTC\"\n```\n:::\n\n`tzone` attribute controls only how the date-time is formatted.\n\n::: {.cell}\n\n```{.r .cell-code}\nSys.timezone() # My time zone\n#> [1] \"Asia/Bangkok\"\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nstructure(now_ct, tzone = \"America/New_York\")\n#> [1] \"2018-08-01 18:00:00 EDT\"\nstructure(now_ct, tzone = \"Asia/Bangkok\")\n#> [1] \"2018-08-02 05:00:00 +07\"\n```\n:::\n\n### Difftimes\n\nDifftimes are built on top of doubles, and have a `units` attribute that determines how the integer should be interpreted\n\n::: {.cell}\n\n```{.r .cell-code}\none_week_1 <- as.difftime(1, units = \"weeks\")\none_week_1\n#> Time difference of 1 weeks\n\ntypeof(one_week_1)\n#> [1] \"double\"\nattributes(one_week_1)\n#> $class\n#> [1] \"difftime\"\n#> \n#> $units\n#> [1] \"weeks\"\n```\n:::\n\n## Lists\n\nLists are a step up in complexity from atomic vectors: each element can be any type, not just vectors.\n\n### Create List\n\n::: {.cell}\n\n```{.r .cell-code}\nl1 <- list(\n  1:3, \n  \"a\", \n  c(TRUE, FALSE, TRUE), \n  c(2.3, 5.9)\n)\n\ntypeof(l1)\n#> [1] \"list\"\nstr(l1)\n#> List of 4\n#>  $ : int [1:3] 1 2 3\n#>  $ : chr \"a\"\n#>  $ : logi [1:3] TRUE FALSE TRUE\n#>  $ : num [1:2] 2.3 5.9\n```\n:::\n\nElements of a list are references, the total size of a list might be smaller than you might expect.\n\n::: {.cell}\n\n```{.r .cell-code}\nlobstr::obj_size(mtcars)\n#> Error in loadNamespace(x): there is no package called 'lobstr'\n\nl2 <- list(mtcars, mtcars, mtcars, mtcars)\nlobstr::obj_size(l2)\n#> Error in loadNamespace(x): there is no package called 'lobstr'\n```\n:::\n\n`c()` will coerce the vectors to lists before combining them into list\n\n::: {.cell}\n\n```{.r .cell-code}\nl5 <- c(\n  list(1, 2), \n  c(3, 4)\n  )\n\nstr(l5)\n#> List of 4\n#>  $ : num 1\n#>  $ : num 2\n#>  $ : num 3\n#>  $ : num 4\n```\n:::\n\n### As List\n\n::: {.cell}\n\n```{.r .cell-code}\nlist(1:2)\n#> [[1]]\n#> [1] 1 2\nas.list(1:2)\n#> [[1]]\n#> [1] 1\n#> \n#> [[2]]\n#> [1] 2\n```\n:::\n\n### List Matrix\n\nWith lists, the dimension attribute can be used to create list-matrices or list-arrays:\n\n::: {.cell}\n\n```{.r .cell-code}\nl <- list(1:3, \"a\", TRUE, 1.0)\ndim(l) <- c(2, 2)\nl\n#>      [,1]      [,2]\n#> [1,] integer,3 TRUE\n#> [2,] \"a\"       1\n```\n:::\n\n## Data Frame\n\n### `data.frame`\n\nA data frame is a named list of vectors with the same length.\n\nAttributes\n\n-   `names`\n-   `row.names`\n\n::: {.cell}\n\n```{.r .cell-code}\ndf1 <- data.frame(x = 1:3, y = letters[1:3])\ntypeof(df1)\n#> [1] \"list\"\nattributes(df1)\n#> $names\n#> [1] \"x\" \"y\"\n#> \n#> $class\n#> [1] \"data.frame\"\n#> \n#> $row.names\n#> [1] 1 2 3\n```\n:::\n\n-   A data frame has [`rownames()`](https://tibble.tidyverse.org/reference/rownames.html) and [`colnames()`](https://rdrr.io/r/base/colnames.html). The [`names()`](https://rdrr.io/r/base/names.html) of a data frame are the column names.\n\n-   A data frame has [`nrow()`](https://rdrr.io/r/base/nrow.html) rows and [`ncol()`](https://rdrr.io/r/base/nrow.html) columns. The [`length()`](https://rdrr.io/r/base/length.html) of a data frame gives the number of columns.\n\n### `tibble`\n\n> Tibbles are lazy and surly: they do less and complain more.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tibble)\n\ndf2 <- tibble(x = 1:3, y = letters[1:3])\ntypeof(df2)\n#> [1] \"list\"\nattributes(df2)\n#> $class\n#> [1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n#> \n#> $row.names\n#> [1] 1 2 3\n#> \n#> $names\n#> [1] \"x\" \"y\"\n```\n:::\n\n### Tibble vs Data Frame\n\n-   Tibbles never coerce their input (but recent version of R data frame also not convert string to factor)\n-   Tibbles do not transform non-syntactic names\n-   Tibbles will only recycle vectors of length one.\n-   Tibbles allows you to refer to variables created during construction:\n\n::: {.cell}\n\n```{.r .cell-code}\ndf2 <- tibble(\n  x = 1:3, \n  y = c(\"a\", \"b\", \"c\")\n)\n\nstr(df2)\n#> tibble [3 × 2] (S3: tbl_df/tbl/data.frame)\n#>  $ x: int [1:3] 1 2 3\n#>  $ y: chr [1:3] \"a\" \"b\" \"c\"\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(data.frame(`1` = 1))\n#> [1] \"X1\"\nnames(tibble(`1` = 1))\n#> [1] \"1\"\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Useful feature\ntibble(\n  x = 1:3,\n  y = x * 2\n)\n#> # A tibble: 3 × 2\n#>       x     y\n#>   <int> <dbl>\n#> 1     1     2\n#> 2     2     4\n#> 3     3     6\n```\n:::\n\n### Rowname\n\n::: callout-caution\n#### Warning\n\nRow names are undesirable\n:::\n\nConvert rowname to column by\n\n-   [`rownames_to_column()`](https://tibble.tidyverse.org/reference/rownames.html)\n-   [`as_tibble()`](https://tibble.tidyverse.org/reference/as_tibble.html) with `rownames` argument\n\n::: {.cell}\n\n```{.r .cell-code}\ndf3 <- data.frame(\n  age = c(35, 27, 18),\n  hair = c(\"blond\", \"brown\", \"black\"),\n  row.names = c(\"Bob\", \"Susan\", \"Sam\")\n)\n\nas_tibble(df3, rownames = \"name\")\n#> # A tibble: 3 × 3\n#>   name    age hair \n#>   <chr> <dbl> <chr>\n#> 1 Bob      35 blond\n#> 2 Susan    27 brown\n#> 3 Sam      18 black\n```\n:::\n\n### Subsetting Caveat\n\n`data.frame` allowed partial matching when subsetting with `$`. It can be a source of bug.\n\n::: {.cell}\n\n```{.r .cell-code}\ndf3$a\n#> [1] 35 27 18\n# If not found\ndf3$x\n#> NULL\n```\n:::\n\nIf you want a single column, recommend using `df[[\"col\"]]`\n\n### List column in Tibble\n\n::: {.cell}\n\n```{.r .cell-code}\ntibble(\n  x = 1:3, \n  y = list(1:2, 1:3, 1:4)\n)\n#> # A tibble: 3 × 2\n#>       x y        \n#>   <int> <list>   \n#> 1     1 <int [2]>\n#> 2     2 <int [3]>\n#> 3     3 <int [4]>\n```\n:::\n\n## NULL\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(NULL)\n#> [1] \"NULL\"\nlength(NULL)\n#> [1] 0\n\nx <- NULL\nattr(x, \"y\") <- 1\n#> Error in attr(x, \"y\") <- 1: attempt to set an attribute on NULL\n```\n:::\n\ntwo common uses of `NULL`:\n\n-   To represent an empty vector (a vector of length zero) of arbitrary type.\n\n-   To represent an absent vector. For example, `NULL` is often used as a default function argument, when the argument is optional but the default value requires some computation. (Contrast this with `NA` which is used to indicate that an *element* of a vector is absent.)",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": [],
    "engineDependencies": {},
    "preserve": {},
    "postProcess": null
  }
}